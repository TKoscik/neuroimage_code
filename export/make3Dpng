#!/bin/bash -e
#===============================================================================
# Make PNG images of brains, suitable for publication.
# -flexible overlay, color, and layout options
# Authors: Timothy R. Koscik, PhD
# Date: 2021-02-04
#===============================================================================
PROC_START=$(date +%Y-%m-%dT%H:%M:%S%z)
FCN_NAME=($(basename "$0"))
DATE_SUFFIX=$(date +%Y%m%dT%H%M%S%N)
OPERATOR=$(whoami)
KERNEL="$(uname -s)"
HARDWARE="$(uname -m)"
HPC_Q=${QUEUE}
HPC_SLOTS=${NSLOTS}
KEEP=false
NO_LOG=false
umask 007

# actions on exit, write to logs, clean scratch
function egress {
  EXIT_CODE=$?
  PROC_STOP=$(date +%Y-%m-%dT%H:%M:%S%z)
  if [[ "${KEEP}" == "false" ]]; then
    if [[ -n ${DIR_SCRATCH} ]]; then
      if [[ -d ${DIR_SCRATCH} ]]; then
        if [[ "$(ls -A ${DIR_SCRATCH})" ]]; then
          rm -R ${DIR_SCRATCH}
        else
          rmdir ${DIR_SCRATCH}
        fi
      fi
    fi
  fi
  if [[ "${NO_LOG}" == "false" ]]; then
    unset LOGSTR
    LOGSTR="${OPERATOR},${DIR_PROJECT},${PID},${SID},${HARDWARE},${KERNEL},${HPC_Q},${HPC_SLOTS},${FCN_NAME},${PROC_START},${PROC_STOP},${EXIT_CODE}"
    writeLog --benchmark --string ${LOGSTR}
  fi
}
trap egress EXIT

# Parse inputs -----------------------------------------------------------------
OPTS=$(getopt -o hvl --long help,verbose,no-log,\
bg:,bg-volume:,bg-mask:,bg-mask-volume:,bg-threshold:,bg-alpha:,bg-color:,bg-order:,bg-cbar,\
fg:,fg-volume:,fg-mask:,fg-mask-volume:,fg-threshold:,fg-alpha:,fg-color:,fg-order:,fg-cbar,\
roi:,roi-volume:,roi-value:,roi-color:,roi-order:,roi-cbar,\
layout:,offset:,limits:,\
no-slice-label,use-vox-label,no-lr-label,label-decimal:,\
color-panel:,color-text:,color-decimal:,font:,font-size:,max-pixels:,\
keep-slice,keep-cbar,\
filename:,dir-save:,dir-scratch: -n 'parse-options' -- "$@")
if [[ $? != 0 ]]; then
  echo "Failed parsing options" >&2
  exit 1
fi
eval set -- "$OPTS"

# Set default values for function ---------------------------------------------
BG=
BG_VOL=1
BG_MASK=
BG_MASK_VOL=1
BG_THRESH=0,100
BG_COLOR="#000000,#FFFFFF"
BG_ORDER="normal"
BG_CBAR="false"
BG_ALPHA=100

FG=
FG_VOL=1
FG_MASK=
FG_MASK_VOL=1
FG_THRESH=0,100
FG_ALPHA=100
FG_COLOR="timbow"
FG_ORDER="normal"
FG_CBAR="true"

ROI=
ROI_VOL=1
ROI_VALUE="all"
ROI_COLOR="#FF69B4"
ROI_ORDER="random"
ROI_CBAR="false"

LAYOUT=1:x,1:y,1:z
OFFSET=1,0,0
LIMITS=
LABEL_NO_SLICE="false"
LABEL_USE_VOX="false"
LABEL_NO_LR="false"
LABEL_DECIMAL=1
COLOR_PANEL="#000000"
COLOR_TEXT="#FFFFFF"
COLOR_DECIMAL=2
FONT=NimbusSans-Regular
FONT_SIZE=24
MAX_PIXELS=500

FILENAME=
DIR_SAVE=
KEEP_SLICE="false"
KEEP_CBAR="false"
DIR_SCRATCH=${INC_SCRATCH}/${OPERATOR}_${DATE_SUFFIX}

HELP="false"
VERBOSE="false"

while true; do
  case "$1" in
    -h | --help) HELP="true" ; shift ;;
    -v | --verbose) VERBOSE="true" ; shift ;;
    -l | --no-log) NO_LOG="true" ; shift ;;
    --bg) BG="$2" ; shift 2 ;;
    --bg-volume) BG_VOL="$2" ; shift 2 ;;
    --bg-mask) BG_MASK="$2" ; shift 2 ;;
    --bg-mask-volume) BG_VOL="$2" ; shift 2 ;;
    --bg-alpha) BG_ALPHA="$2" ; shift 2 ;;
    --bg-threshold) BG_THRESH="$2" ; shift 2 ;;
    --bg-color) BG_COLOR="$2" ; shift 2 ;;
    --bg-order) BG_ORDER="$2" ; shift 2 ;;
    --bg-cbar) BG_CBAR="true" ; shift ;;
    --fg) FG="$2" ; shift 2 ;;
    --fg-volume) FG_VOL="$2" ; shift 2 ;;
    --fg-mask) FG_MASK="$2" ; shift 2 ;;
    --fg-mask-volume) FG_VOL="$2" ; shift 2 ;;
    --fg-alpha) FG_ALPHA="$2" ; shift 2 ;;
    --fg-threshold) FG_THRESH="$2" ; shift 2 ;;
    --fg-color) FG_COLOR="$2" ; shift 2 ;;
    --fg-order) FG_ORDER="$2" ; shift 2 ;;
    --fg-cbar) FG_CBAR="false" ; shift ;;
    --roi) ROI="$2" ; shift 2 ;;
    --roi-volume) ROI_VOL="$2" ; shift 2 ;;
    --roi-value) ROI_VALUE="$2" ; shift 2 ;;
    --roi-color) ROI_COLOR="$2" ; shift 2 ;;
    --roi-order) ROI_ORDER="$2" ; shift 2 ;;
    --roi-cbar) ROI_CBAR="true" ; shift ;;
    --layout) LAYOUT="$2" ; shift 2 ;;
    --offset) OFFSET="$2" ; shift 2 ;;
    --limits) LIMITS="$2" ; shift 2 ;;
    --no-slice-label) LABEL_NO_SLICE="true" ; shift ;;
    --use-vox-label) LABEL_USE_VOX="true" ; shift ;;
    --no-lr-label) LABEL_NO_LR="true" ; shift ;;
    --label-decimal) LABEL_DECIMAL="$2" ; shift 2 ;;
    --color-panel) COLOR_PANEL="$2" ; shift 2 ;;
    --color-text) COLOR_TEXT="$2" ; shift 2 ;;
    --color-decimal) COLOR_DECIMAL="$2" ; shift 2 ;;
    --font) FONT="$2" ; shift 2 ;;
    --font-size) FONT_SIZE="$2" ; shift 2 ;;
    --max-pixels) MAX_PIXELS="$2" ; shift 2 ;;
    --filename) FILENAME="$2" ; shift 2 ;;
    --dir-save) DIR_SAVE="$2" ; shift 2 ;;
    --dir-scratch) DIR_SCRATCH="$2" ; shift 2 ;;
    --keep-slice) KEEP_SLICE="true" ; shift ;;
    --keep-cbar) KEEP_CBAR="true" ; shift ;;
    -- ) shift ; break ;;
    * ) break ;;
  esac
done

# Usage Help -------------------------------------------------------------------
if [[ "${HELP}" == "true" ]]; then
  echo ''
  echo '------------------------------------------------------------------------'
  echo "Iowa Neuroimage Processing Core: ${FCN_NAME}"
  echo '------------------------------------------------------------------------'
  echo '  -h | --help       display command help'
  echo '  -v | --verbose    add verbose output to log file'
  echo '  -l | --no-log     disable writing to output log'
  echo '--bg                path to NIfTI file for background, single volume'
  echo '                      e.g., anatomical'
  echo '--bg-volume         volume to use for multivolume image, default=1'
  echo '--bg-mask           region to plot, will be binarized'
  echo '--bg-mask-volume    volume for multivolume mask, default=1'
  echo '--bg-threshold      background intensity range, default=0,100'
  echo '--bg-color          color scale for background, details below'
  echo '--bg-order          order of the color bar, details below'
  echo '--bg-cbar           toggle to turn ON color bar for background'
  echo '--fg                path to NIfTI file for foreground, single-volume'
  echo '                    multiple FG images semicolon-delimited,'
  echo '                    plotted in order specified, 1st on bottom'
  echo '--fg-mask           region to plot, will be binarized'
  echo '--fg-mask-volume    volume for multivolume mask, default=1'
  echo '--fg-threshold      foreground intensity range, default=0,100'
  echo '--fg-alpha          strength of foreground overlay on preceeding layers'
  echo '                      (0-100), default=75'
  echo '--fg-color          color scale for foreground, details below'
  echo '                      semicolon-delimited color schemes corresponding'
  echo '                      to multiple foreground images'
  echo '--fg-order          order of the color bar, details below'
  echo '--fg-cbar           toggle to turn ON color bar for foreground'
  echo '--roi               path to NIfTI file to plot ROI outlines,'
  echo '                    should be integer values corresponding to'
  echo '                    regional labels, semicolon delimited for'
  echo '                    multiple files. All are combined into a single'
  echo '                    sequentially numbered label set'
  echo '--roi-volume        volume(s) for multi volume label files,'
  echo '                      -all for all volumes in a file'
  echo '                      -semicolon-delimiters for multiple files'
  echo '                      -comma-delimiters for lists of single volumes'
  echo '                      -colon-delimiters for ranges of volumes'
  echo '                      e.g., 1,3:5;all;1'
  echo '                        would yield: volumes 1,3,4,5 from ROI 1'
  echo '                                     all volumes from ROI 2'
  echo '                                     volume 1 from ROI 3'
  echo '--roi-value         which label values from a file to include,'
  echo '                    will be applied to all volumes from that ROI file'
  echo '                    specification is the same as for ROI volumes'
  echo '--roi-color         color scheme to use for ROIs, default="#FF69B4" (hot pink)'
  echo '--roi-order         order of the color bar, details below'
  echo '--roi-cbar          toggle to turn ON color bar for ROI'
  echo '--layout            a string identifying the number of'
  echo '                    slices, slice plane, rows and columns'
  echo '                    Layouts are specifed by using delimiters:'
  echo '                      (;) row delimiter'
  echo '                      (,) column delimiter'
  echo '                      (:) number and plane delimiter'
  echo '                        Applied in row -> column -> plane order'
  echo '                      See examples below, default=1:x,1:y,1:z'
  echo '--offset            number of slices to shift slices from calculated values'
  echo '                    perhaps to shift away from central slice slightly to'
  echo '                    not view falx. Comma-delimted for offsets in each'
  echo '                    plane (x,y,z), default=1,0,0'
  echo '--limits            by default image limits are calculated based on inputs'
  echo '                    in the order preferring: ROI > FG_MASK > FG > BG_MASK > BG'
  echo '                    image used for calculation can be specified:'
  echo '                      (semicolon-delimited nuymber for multi-file inputs)'
  echo '                      BG, BG_MASK, FG, FG;#, FG_MASK, FG_MASK;#, ROI, ROI;#'
  echo '                    or voxel values can be provided directly:'
  echo '                      (semicolon-delimited planes, comma-delimited min,max)'
  echo '                      10,100;13,130;45,150'
  echo '                      NA,NA;NA,NA;10,100'
  echo '--no-slice-label    toggle, turn off location labels'
  echo '--use-voxel-label   toggle, use voxels not mm for location label'
  echo '--no-lr-label       toggle, turn off L and R indicator'
  echo '--label-decimal     number of decimal places for labels, default=1'
  echo '--color-panel       color of background in image, default="#000000"'
  echo '--color-text        color of text elements, default="#FFFFFF"'
  echo '--color-decimal     number of decimal places of color bar labels, default=2'
  echo '--font              name of font to be used, default=NimbusSans-Regular'
  echo '--font-size         font size to use in final image, default=24'
  echo '                    might need to be adjusted depending on image size'
  echo '--max-pixels        maximum number of pixels for each slice, default=500'
  echo '                    This will up- or down-sample slices accordingly,'
  echo '                    but will retain aspect ratios'
  echo '--filename          desired filename of output image,'
  echo '                    default=sub-${PID}_ses-${SID}_YYMMDDThhmmssnnn'
  echo '                            overlay4D_YYMMDDThhmmssnnn'
  echo '--dir-save          location to save final image'
  echo '--dir_scratch       directory to use to construct image'
  echo '--keep-slice        toggle, keep individual slices, same save directory'
  echo '--keep-cbar         toggle to keep color bar images, same save directory'
  echo ''
  echo ' Details: --------------------------------------------------------------'
  echo 'thresholds:   comma-delimited minimum and maximum range of image values to'
  echo '              plot as a % of total range (0-100). default=0,100'
  echo 'colors:   colors can be specified via any comma-delimited combination of'
  echo '          HEX colors in order from low to high. Color gradients will be'
  echo '          constructed evenly distributing colors across the image range.'
  echo '          example: Red - White - Blue color gradients'
  echo '                   "#FF0000,#FFFFFF,#0000FF"'
  echo '          Several named color schemes are available:'
  echo '          -(timbow)  a rainbow color scheme based on colors from viridis'
  echo '          -viridis   including: viridis, magma, inferno, plasma, and'
  echo '                               cividis variants'
  echo '          -cubehelix  a common astronomical color gradient, where colors'
  echo '                      are selected such that intensity varies continuously'
  echo '                      from low to high along with color.'
  echo '                      Optional parameters can be specified as'
  echo '                      comma-delimited, named values after cubehelix,'
  echo '                        default="cubehelix,start,0.5,r,-1.5,hue,2,gamma,1"'
  echo '          -hot        "hot" colors, Dark red to bright yellow'
  echo '                        "#7F0000,#FF0000,#FF7F00,#FFFF00,#FFFF7F"'
  echo '          -cold       "cold" colors, dark blue to bright cyan'
  echo '                        "#00007F,#0000FF,#007FFF,#00FFFF,#7FFFFF"'
  echo '          -grayscale  [grayscale, gray, grey] "#000000,#FFFFFF"'
  echo '          -rainbow    rainbow colors, commonly referred to as "jet"'
  echo '                        "#FF0000,#FFFF00,#00FF00,#00FFFF,#0000FF,#FF00FF"'
  echo 'color order:   A modifier to add to change to the order that colors are used'
  echo '               in the color scheme. Options include:'
  echo '                 r, rand, random: randomize the order of colors'
  echo '                 rev, reverse, i, inv, inverse: invert the order of colors'
  echo ' Example Layouts:'
  echo ' (1) 3 slices, 1 from each plane in a horizontal array:'
  echo '     offset 1 slice from center'
  echo '     >>  --layout 1:x,1:y,1:z'
  echo '     >>  --offset 1,1,1'
  echo ' (2) single plane, 5x5 axial montage layout:'
  echo '     >>  --layout 5:z;5:z;5:z;5:z;5:z'
  echo '     >>  --offset 0,0,0'
  echo ' (3) 3x5 montage layout, single plane in each row:'
  echo '     - row 1: 5 slices in x-plane'
  echo '     - row 2: 5 slices in y-plane'
  echo '     - row 3: 5 slices in z-plane'
  echo '     >>  --layout 5:x;5:y;5:z'
  echo '     >>  --offset 0,0,0'
  NO_LOG=true
  exit 0
fi

#===============================================================================
# Start of Function
#===============================================================================
if [[ "${VERBOSE}" == "true" ]]; then echo "Running INC 3D PNG Maker:"; fi

# set default filename ---------------------------------------------------------
if [[ "${VERBOSE}" == "true" ]]; then echo ">>>setting output filename"; fi
DIR_PROJECT=$(getDir -i ${BG})
PID=$(getField -i ${BG} -f sub)
SID=$(getField -i ${BG} -f ses)
DIRPID=sub-${PID}
if [[ -z "${FILENAME}" ]]; then
  FBASE=$(basename ${BG})
  FILENAME="${FBASE%%.*}"  
fi

# set default save directory ---------------------------------------------------
if [[ "${VERBOSE}" == "true" ]]; then echo ">>>setting directories for scratch and saving"; fi
if [[ -z ${DIR_SAVE} ]]; then DIR_SAVE=$(dirname ${BG}); fi
mkdir -p ${DIR_SAVE}
mkdir -p ${DIR_SCRATCH}
if [[ "${VERBOSE}" == "true" ]]; then
  echo -e "SAVE LOCATION:\t${DIR_SAVE}"
  echo -e "PNG FILENAME:\t${FILENAME}.png"
fi

# parse parameters for FG and ROIs ---------------------------------------------
if [[ "${VERBOSE}" == "true" ]]; then echo ">>>parsing FG arguments"; fi
FG=(${FG//;/ })
FG_VOL=(${FG_VOL//;/ })
FG_MASK=(${FG_MASK//;/ })
FG_MASK_VOL=(${FG_MASK_VOL//;/ })
FG_THRESH=(${FG_THRESH//;/ })
FG_COLOR=(${FG_COLOR//;/ })
FG_ORDER=(${FG_COLOR_ORDER//;/ })
FG_CBAR=(${FG_CBAR//;/ })
FG_N=${#FG[@]}
if [[ ${FG_N} -gt 1 ]]; then
  if [[ ${#FG_VOL[@]} -eq 1 ]]; then
    for (( i=0; i<${FG_N}; i++ )); do
      FG_VOL[${i}]=(${FG_VOL[0]})
    done
  fi
  if [[ ${#FG_MASK_VOL[@]} -eq 1 ]]; then
    for (( i=0; i<${FG_N}; i++ )); do
      FG_MASK_VOL[${i}]=(${FG_MASK_VOL[0]})
    done
  fi
fi

if [[ "${VERBOSE}" == "true" ]]; then echo ">>>parsing ROI arguments"; fi
ROI=(${ROI//;/ })
ROI_VOL=(${ROI_VOL//;/ })
ROI_VALUE=(${ROI_VALUE//;/ })
ROI_COLOR=(${ROI_COLOR//;/ })
ROI_ORDER=(${ROI_ORDER//;/ })
ROI_CBAR=(${ROI_CBAR//;/ })
OFFSET=(${OFFSET//,/ })

# Get image information -------------------------------------------------------
unset DIMS PIXDIM ORIGIN ORIENT
DIMS=($(niiInfo -i ${BG} -f voxels))
PIXDIM=($(niiInfo -i ${BG} -f space))
ORIGIN=($(niiInfo -i ${BG} -f origin))
ORIENT=($(niiInfo -i ${BG} -f orient))
if [[ "${VERBOSE}" == "true" ]]; then
  echo ">>>pulling background information from NII header"
  echo -e "DIMS:\t${DIMS[@]}"
  echo -e "PIXDIM:\t${PIXDIM[@]}"
  echo -e "ORIGIN:\t${ORIGIN[@]}"
  echo -e "ORIENT:\t${ORIENT[@]}"
fi

## use mm only if image is in known standard space -----------------------------
if [[ "${LABEL_NO_SLICE}" == "false" ]] &&
   [[ "${LABEL_USE_VOX}" == "false" ]]; then
  LABEL_USE_VOX="true"
  MSG=">>>using voxel coordinate labels"
  STD_LS=($(ls ${DIR_TEMPLATE}))
  for (( i=0; i<${#STD_LS[@]}; i++ )); do
    if [[ "${BG}" == *"${STD_LS[${i}]}"* ]]; then
      LABEL_USE_VOX="false"
      MSG=">>>using mm coordinate labels"
      break
    fi
  done
fi
if [[ "${VERBOSE}" == "true" ]]; then echo ${MSG}; fi

# Figure out number slices for each orientation --------------------------------
if [[ "${VERBOSE}" == "true" ]]; then echo ">>>parsing layout slice number and orientation"; fi
NX=0; NY=0; NZ=0
ROW_LAYOUT=(${LAYOUT//\;/ })
for (( i=0; i<${#ROW_LAYOUT[@]}; i++ )); do
  COL_LAYOUT=(${ROW_LAYOUT[${i}]//\,/ })
  for (( j=0; j<${#COL_LAYOUT[@]}; j++ )); do
    TEMP=(${COL_LAYOUT[${j}]//\:/ })
    case ${TEMP[1]} in 
      x) NX=$((${NX}+${TEMP[0]})) ;;
      y) NY=$((${NY}+${TEMP[0]})) ;;
      z) NZ=$((${NZ}+${TEMP[0]})) ;;
    esac
  done
done
if [[ "${VERBOSE}" == "true" ]]; then echo -e "NX:${NX}\tNY:${NY}\tNZ:${NZ}"; fi

# select desired volume from multivolume images --------------------------------
if [[ "${VERBOSE}" == "true" ]]; then echo ">>>selecting desired volumes if multivolume images"; fi
TV=$(niiInfo -i ${BG} -f vols)
if [[ ${TV} -gt 1 ]]; then
  if [[ ${BG_VOL} > ${TV} ]]; then
    echo "ERROR [INC:${FCN_NAME}] BG_VOL out of range, <${TV}"
    exit 1
  else
    WHICH_VOL=$((${BG_VOL}-1))
    fslroi ${BG} ${DIR_SCRATCH}/BG.nii.gz ${WHICH_VOL} 1
    BG=${DIR_SCRATCH}/BG.nii.gz
  fi
fi

if [[ -n ${BG_MASK} ]]; then
  TV=$(niiInfo -i ${BG_MASK} -f vols)
  if [[ ${TV} -gt 1 ]]; then
    if [[ ${BG_MASK_VOL} > ${TV} ]]; then
      echo "ERROR [INC:${FCN_NAME}] BG_MASK_VOL out of range, <${TV}"
      exit 1
    else
      WHICH_VOL=$((${BG_MASK_VOL}-1))
      fslroi ${BG_MASK} ${DIR_SCRATCH}/BG_MASK.nii.gz ${WHICH_VOL} 1
      BG_MASK=${DIR_SCRATCH}/BG_MASK.nii.gz
    fi
  fi
fi

if [[ -n ${FG} ]]; then
  for (( i=0; i<${FG_N}; i++ )); do
    TV=$(niiInfo -i ${FG[${i}]} -f vols)
    if [[ ${TV} -gt 1 ]]; then
      if [[ ${FG_VOL[${i}]} > ${TV} ]]; then
        echo "ERROR [INC:${FCN_NAME}] FG_VOL[${i}] out of range, <${TV}"
        exit 1
      else
        WHICH_VOL=$((${FG_VOL[${i}]}-1))
        fslroi ${FG[${i}]} ${DIR_SCRATCH}/FG_${i}.nii.gz ${WHICH_VOL} 1
        FG[${i}]=${DIR_SCRATCH}/FG_${i}.nii.gz
      fi
    fi
  done
fi

if [[ -n ${FG_MASK} ]]; then
  for (( i=0; i<${FG_N}; i++ )); do
    TV=$(niiInfo -i ${FG_MASK[${i}]} -f vols)
    if [[ ${TV} -gt 1 ]]; then
      if [[ ${FG_MASK_VOL[${i}]} > ${TV} ]]; then
        echo "ERROR [INC:${FCN_NAME}] FG_MASK_VOL[${i}] out of range, <${TV}"
        exit 1
      else
        WHICH_VOL=$((${FG_MASK_VOL[${i}]}-1))
        fslroi ${FG_MASK[${i}]} ${DIR_SCRATCH}/FG_MASK_${i}.nii.gz ${WHICH_VOL} 1
        FG_MASK[${i}]=${DIR_SCRATCH}/FG_MASK_${i}.nii.gz
      fi
    fi
  done
fi

if [[ -n ${ROI} ]]; then
  if [[ "${VERBOSE}" == "true" ]]; then echo ">>>merging labels into unique set"; fi
  labelUnique --label ${ROI} --volume ${ROI_VOL} --value ${ROI_VALUE} \
    --dir-save ${DIR_SCRATCH} --prefix ROI
  ROI=${DIR_SCRATCH}/ROI.nii.gz
  ROI_VOL=1
  ROI_VALUE="all"
fi

# Calculate slices to plot =====================================================
# parse variable to determine image limits ------------------------------------
if [[ "${VERBOSE}" == "true" ]]; then echo ">>>determine source of image limits"; fi
if [[ -z "${LIMITS}" ]]; then
  if [[ -n ${ROI} ]]; then 
    if [[ "${VERBOSE}" == "true" ]]; then echo ">>>>>>using ROI"; fi
    LIM_CHK=(${LIM_CHK[@]} ${ROI[@]})
  elif [[ -n ${FG_MASK} ]]; then
    if [[ "${VERBOSE}" == "true" ]]; then echo ">>>>>>using FG mask"; fi
    LIM_CHK=(${LIM_CHK[@]} ${FG_MASK[@]})
  elif [[ -n ${FG} ]]; then
    if [[ "${VERBOSE}" == "true" ]]; then echo ">>>>>>using FG"; fi
    LIM_CHK=(${LIM_CHK[@]} ${FG[@]})
  elif [[ -n ${BG_MASK} ]]; then
    if [[ "${VERBOSE}" == "true" ]]; then echo ">>>>>>using BG mask"; fi
    LIM_CHK=(${LIM_CHK[@]} ${BG_MASK})
  else
    if [[ "${VERBOSE}" == "true" ]]; then echo ">>>>>>using BG"; fi
    LIM_CHK=(${LIM_CHK[@]} ${BG})
  fi
elif [[ "${LIMITS^^}" == "BG" ]]; then
  if [[ "${VERBOSE}" == "true" ]]; then echo ">>>>>>using BG"; fi
  LIM_CHK=(${LIM_CHK[@]} ${BG})
elif [[ "${LIMITS^^}" == "BG_MASK" ]]; then
  if [[ "${VERBOSE}" == "true" ]]; then echo ">>>>>>using BG mask"; fi
  LIM_CHK=(${LIM_CHK[@]} ${BG_MASK})
elif [[ "${LIMITS^^}" == *"FG"* ]]; then
  TEMP=(${LIMITS//;/ })
  if [[ "${TEMP[0]}" == "FG" ]]; then
    if [[ "${VERBOSE}" == "true" ]]; then echo ">>>>>>using FG"; fi
    LIM_CHK=(${LIM_CHK[@]} ${FG[@]})
  elif  [[ "${TEMP[0]}" == "FG_MASK" ]]; then
    if [[ "${VERBOSE}" == "true" ]]; then echo ">>>>>>using FG mask"; fi
    LIM_CHK=(${LIM_CHK[@]} ${FG_MASK[@]})
  fi
  if [[ ${#TEMP[@]} -gt 1 ]]; then
    LIM_CHK=${LIM_CHK[${#TEMP[@]}]}
  fi
elif [[ "${LIMITS^^}" == *"ROI"* ]]; then
  if [[ "${VERBOSE}" == "true" ]]; then echo ">>>>>>using ROI"; fi
  TEMP=(${LIMITS//;/ })
  LIM_CHK=(${LIM_CHK[@]} ${FG[@]})
  if [[ ${#TEMP[@]} -gt 1 ]]; then
    LIM_CHK=${LIM_CHK[${#TEMP[@]}]}
  fi
else
  LIMITS_TEMP=(${LIMITS//;/ })
fi

## calculate slices in each plane ----------------------------------------------
## (1) find bounding box within image
## (2) add in desired offset
## (3) constrain limits to image boundaries
## (4) calculate slices to use
### (4a) get edge slices if possible, and toss to avoid edges of image/roi
### (4b) constrain to desired slice number, or fewer if slices unavailable
## (5) convert to percentage of image width for FSL slicer

## (1) find bounding box within image - - - - - - - - - - - - - - - - - - - - -
if [[ "${VERBOSE}" == "true" ]]; then echo ">>>calculating image limits"; fi
unset XLIM YLIM ZLIM
XLIM=(9999 0)
YLIM=(9999 0)
ZLIM=(9999 0)
if [[ -n "${LIM_CHK}" ]]; then
  for (( i=0; i<${#LIM_CHK[@]}; i++ )); do
    unset BB_STR BB
    BB_STR=$(3dAutobox -extent -input ${LIM_CHK[${i}]} 2>&1)
    BBX=$(echo ${BB_STR} | sed -e 's/.*x=\(.*\) y=.*/\1/') #"#'# prevents bad syntax highlighting
    BBY=$(echo ${BB_STR} | sed -e 's/.*y=\(.*\) z=.*/\1/') #"#'#
    BBZ=$(echo ${BB_STR} | sed -e 's/.*z=\(.*\) Extent.*/\1/') #"#'#
    BBX=(${BBX//../ });
    BBY=(${BBY//../ });
    BBZ=(${BBZ//../ });
    if [[ ${BBX[0]} -lt ${XLIM[0]} ]]; then XLIM[0]=${BBX[0]}; fi
    if [[ ${BBX[1]} -gt ${XLIM[1]} ]]; then XLIM[1]=${BBX[1]}; fi
    if [[ ${BBY[0]} -lt ${YLIM[0]} ]]; then YLIM[0]=${BBY[0]}; fi
    if [[ ${BBY[1]} -gt ${YLIM[1]} ]]; then YLIM[1]=${BBY[1]}; fi
    if [[ ${BBZ[0]} -lt ${ZLIM[0]} ]]; then ZLIM[0]=${BBZ[0]}; fi
    if [[ ${BBZ[1]} -gt ${ZLIM[1]} ]]; then ZLIM[1]=${BBZ[1]}; fi
  done
else
  XLIM=(${LIMITS_TEMP[0]//,/ })
  YLIM=(${LIMITS_TEMP[1]//,/ })
  ZLIM=(${LIMITS_TEMP[2]//,/ })
  if [[ "${XLIM[0]^^}" == "NA" ]]; then XLIM[0]=1; fi
  if [[ "${YLIM[0]^^}" == "NA" ]]; then YLIM[0]=1; fi
  if [[ "${ZLIM[0]^^}" == "NA" ]]; then ZLIM[0]=1; fi
  if [[ "${XLIM[1]^^}" == "NA" ]]; then XLIM[1]=${DIMS[0]}; fi
  if [[ "${YLIM[1]^^}" == "NA" ]]; then YLIM[1]=${DIMS[1]}; fi
  if [[ "${ZLIM[1]^^}" == "NA" ]]; then ZLIM[1]=${DIMS[2]}; fi
fi
if [[ "${VERBOSE}" == "true" ]]; then
  echo -e "XLIM=${XLIM[@]}\tYLIM=${YLIM[@]}\tZLIM=${ZLIM[@]}"
fi

# Figure out number slices for each orientation --------------------------------
unset PLANE
NX=0; NY=0; NZ=0
ROW_LAYOUT=(${LAYOUT//\;/ })
for (( i=0; i<${#ROW_LAYOUT[@]}; i++ )); do
  COL_LAYOUT=(${ROW_LAYOUT[${i}]//\,/ })
  for (( j=0; j<${#COL_LAYOUT[@]}; j++ )); do
    TEMP=(${COL_LAYOUT[${j}]//\:/ })
    case ${TEMP[1]} in 
      x) NX=$((${NX}+${TEMP[0]}))
         PLANE+=("x")
         ;;
      y) NY=$((${NY}+${TEMP[0]}))
         PLANE+=("y")
         ;;
      z) NZ=$((${NZ}+${TEMP[0]}))
         PLANE+=("z")
         ;;
    esac
  done
done

# Calculate slices -------------------------------------------------------------
## -calculate limits + offset
## -check if limits are within the image
## -increase number of slices by 1 so that slices that are used are centered
##  within the selected area and not on an edge of the image
## -calculate the step size (in slices) between successive slices for the image
## -get the sequence of voxels corresponding to desired slices and step size
## -remove edge padding slices
## -check if rounding in step size lead to slice count not equalling the desired
##  value, strip necessary slices
## -convert to percentage of image extent

## calculate X slices - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
if [[ ${NX} > 0 ]]; then
  unset XVOX XPCT RANGE TN STEP
  XLIM[0]=$((${XLIM[0]}+${OFFSET[0]}))
  XLIM[1]=$((${XLIM[1]}+${OFFSET[0]}))
  if [[ ${XLIM[0]} -lt 1 ]]; then XLIM[0]=1; fi
  if [[ ${XLIM[1]} -gt ${DIMS[0]} ]]; then XLIM[1]=${DIMS[0]}; fi
  TN=$((${NX}+1))
  STEP=$(ezMath -x "(${XLIM[1]}-${XLIM[0]})/${TN}" -d 0)
  XVOX=($(seq ${XLIM[0]} ${STEP} ${XLIM[1]}))
  if [[ ${#XVOX[@]} -gt ${NX} ]]; then XVOX=${XVOX[@]:1:${#XVOX[@]}-1}; fi
  if [[ ${#XVOX[@]} -gt ${NX} ]]; then unset XVOX[${#XVOX[@]}-1]; fi
  if [[ ${#XVOX[@]} -gt ${NX} ]]; then XVOX=(${XVOX[@]:1:${NX}}); fi
  for (( i=0; i<${NX}; i++ )); do
    XPCT+=($(ezMath -x "(${XVOX[${i}]}/${DIMS[0]})" -d 4))
  done
  if [[ "${VERBOSE}" == "true" ]]; then
    echo -e ">>>X Slice Information:"
    echo -e "Xrange:\t${XLIM[0]} to ${XLIM[1]} by ${STEP}"
    echo -e "Xvoxel:\t${XVOX[@]}"
    echo -e "NX:\t${NX[@]}"
    echo -e "X%:\t${XPCT[@]}"
  fi
fi

## calculate Y slices - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
if [[ ${NY} > 0 ]]; then
  unset YVOX YPCT RANGE STEP TN
  YLIM[0]=$((${YLIM[0]}+${OFFSET[1]}))
  YLIM[1]=$((${YLIM[1]}+${OFFSET[1]}))
  if [[ ${YLIM[0]} -lt 1 ]]; then YLIM[0]=1; fi
  if [[ ${YLIM[1]} -gt ${DIMS[1]} ]]; then YLIM[1]=${DIMS[1]}; fi
  TN=$((${NY}+1))
  STEP=$(ezMath -x "(${YLIM[1]}-${YLIM[0]})/${TN}" -d 0)
  YVOX=($(seq ${YLIM[0]} ${STEP} ${YLIM[1]}))
  if [[ ${#YVOX[@]} -gt ${NY} ]]; then YVOX=${YVOX[@]:1:${#YVOX[@]}-1}; fi
  if [[ ${#YVOX[@]} -gt ${NY} ]]; then unset YVOX[${#YVOX[@]}-1]; fi
  if [[ ${#YVOX[@]} -gt ${NY} ]]; then YVOX=(${YVOX[@]:1:${NY}}); fi
  for (( i=0; i<${NY}; i++ )); do
    YPCT+=($(ezMath -x "${YVOX[${i}]}/${DIMS[1]}" -d 4))
  done
  if [[ "${VERBOSE}" == "true" ]]; then
    echo ">>>Y Slice Information"
    echo -e "Yrange:\t${YLIM[0]} to ${YLIM[1]} by ${STEP}"
    echo -e "Yvoxel:\t${YVOX[@]}"
    echo -e "NY:\t${NY[@]}"
    echo -e "Y%:\t${YPCT[@]}"
  fi
fi

## calculate Z slices - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
if [[ ${NZ} > 0 ]]; then
  unset ZVOX ZPCT RANGE STEP TN
  ZLIM[0]=$((${ZLIM[0]}+${OFFSET[2]}))
  ZLIM[1]=$((${ZLIM[1]}+${OFFSET[2]}))
  if [[ ${ZLIM[0]} -lt 1 ]]; then ZLIM[0]=1; fi
  if [[ ${ZLIM[1]} -gt ${DIMS[2]} ]]; then ZLIM[1]=${DIMS[2]}; fi
  TN=$((${NZ} + 1))
  STEP=$(ezMath -x "(${ZLIM[1]}-${ZLIM[0]})/${TN}" -d 0)
  ZVOX=($(seq ${ZLIM[0]} ${STEP} ${ZLIM[1]}))
  if [[ ${#ZVOX[@]} -gt ${NZ} ]]; then ZVOX=${ZVOX[@]:1:${#ZVOX[@]}-1}; fi
  if [[ ${#ZVOX[@]} -gt ${NZ} ]]; then unset ZVOX[${#ZVOX[@]}-1]; fi
  if [[ ${#ZVOX[@]} -gt ${NZ} ]]; then ZVOX=(${ZVOX[@]:1:${NZ}}); fi
  for (( i=0; i<${NZ}; i++ )); do
    ZPCT+=($(ezMath -x "${ZVOX[${i}]}/${DIMS[2]}" -d 4))
  done
  if [[ "${VERBOSE}" == "true" ]]; then
    echo ">>>Z Slice Information"
    echo -e "Zrange:\t${ZLIM[0]} to ${ZLIM[1]} by ${STEP}"
    echo -e "Zvoxel:\t${ZVOX[@]}"
    echo -e "NZ:\t${NZ[@]}"
    echo -e "Z%:\t${ZPCT[@]}"
  fi
fi

#===============================================================================
# check if all images in same space --------------------------------------------
if [[ "${VERBOSE}" == "true" ]]; then echo ">>>check if images in same space, if not try forcing"; fi
FIELD_CHK="dim,pixdim,quatern_b,quatern_c,quatern_d,qoffset_x,qoffset_y,qoffset_z,srow_x,srow_y,srow_z"
if [[ -n ${BG_MASK} ]]; then
  unset SPACE_CHK
  SPACE_CHK=$(niiCompare -i ${BG} -j ${BG_MASK} -f ${FIELD_CHK})
  if [[ "${SPACE_CHK}" == "false" ]]; then
    antsApplyTransforms -d 3 -n GenericLabel \
      -i ${BG_MASK} -o ${DIR_SCRATCH}/BG_mask.nii.gz -r ${BG}
    BG_MASK="${DIR_SCRATCH}/BG_mask.nii.gz"
  fi
fi
if [[ -n ${FG_MASK} ]]; then
  for (( i=0; i<${#FG_MASK[@]}; i++ )); do
    unset SPACE_CHK
    SPACE_CHK=$(niiCompare -i ${FG[${i}]} -j ${FG_MASK[${i}]} -f ${FIELD_CHK})
    if [[ "${SPACE_CHK}" == "false" ]]; then
      antsApplyTransforms -d 3 -n GenericLabel \
        -i ${FG_MASK[${i}]} -o ${DIR_SCRATCH}/FG_mask-${i}.nii.gz -r ${FG[${i}]}
      FG_MASK[${i}]="${DIR_SCRATCH}/FG_mask-${i}.nii.gz"
    fi
  done
fi
if [[ -n ${ROI} ]]; then
  for (( i=1; i<${#ROI[@]}; i++ )); do
    unset SPACE_CHK
    SPACE_CHK=$(niiCompare -i ${ROI[0]} -j ${ROI[${i}]} -f ${FIELD_CHK})
    if [[ "${SPACE_CHK}" == "false" ]]; then
      antsApplyTransforms -d 3 -n MultiLabel \
        -i ${ROI[${i}]} -o ${DIR_SCRATCH}/ROI_${i}.nii.gz -r ${ROI[0]}
      ROI[${i}]="${DIR_SCRATCH}/ROI_${i}.nii.gz"
    fi
  done
fi

# make panel background ========================================================
if [[ "${VERBOSE}" == "true" ]]; then echo ">>>generate PNG background"; fi
RESIZE_STR="${MAX_PIXELS}x${MAX_PIXELS}"
for (( i=0; i<${NX}; i++ )); do
  convert -size ${RESIZE_STR} canvas:${COLOR_PANEL} ${DIR_SCRATCH}/X${i}.png
done
for (( i=0; i<${NY}; i++ )); do
  convert -size ${RESIZE_STR} canvas:${COLOR_PANEL} ${DIR_SCRATCH}/Y${i}.png
done
for (( i=0; i<${NZ}; i++ )); do
  convert -size ${RESIZE_STR} canvas:${COLOR_PANEL} ${DIR_SCRATCH}/Z${i}.png
done

# Make Background ==============================================================
## generate color bar
if [[ "${VERBOSE}" == "true" ]]; then echo ">>>make BG color bar"; fi
Rscript ${INC_R}/makeColors.R \
  "palette" ${BG_COLOR} "n" 200 \
  "order" ${BG_ORDER} "bg" ${COLOR_PANEL} \
  "dir.save" ${DIR_SCRATCH} "prefix" "CBAR_BG"
Rscript ${INC_R}/makeColors.R \
  "palette" "#000000,#FFFFFF" "n" 2 "no.png" \
  "dir.save" ${DIR_SCRATCH} "prefix" "CBAR_MASK"

### add labels to color bar
if [[ "${BG_CBAR}" == "true" ]]; then
  text_fcn='TTXT=$(printf "%0.'${COLOR_DECIMAL}'f\n" ${LO})'
  eval ${text_fcn}
  convert -background "transparent" -fill ${COLOR_TEXT} \
    -font ${FONT} -pointsize ${FONT_SIZE} \
    caption:"${TTXT}" -rotate 90 ${DIR_SCRATCH}/LABEL_LO.png
  text_fcn='TTXT=$(printf "%0.'${COLOR_DECIMAL}'f\n" ${HI})'
  eval ${text_fcn}
  convert -background "transparent" -fill ${COLOR_TEXT} \
    -font ${FONT} -pointsize ${FONT_SIZE} \
    caption:"${TTXT}" -rotate 90 ${DIR_SCRATCH}/LABEL_HI.png
  composite -gravity SouthEast \
    ${DIR_SCRATCH}/LABEL_LO.png \
    ${DIR_SCRATCH}/CBAR_BG.png \
    ${DIR_SCRATCH}/CBAR_BG.png
  composite -gravity NorthEast \
    ${DIR_SCRATCH}/LABEL_HI.png \
    ${DIR_SCRATCH}/CBAR_BG.png \
    ${DIR_SCRATCH}/CBAR_BG.png
fi

## generate slice PNGs
if [[ "${VERBOSE}" == "true" ]]; then echo ">>>generate background slices"; fi
HILO=(${BG_THRESH//,/ })
if [[ -n ${BG_MASK} ]]; then
  LO=$(fslstats -K ${BG_MASK} ${BG} -p ${HILO[0]})
  HI=$(fslstats -K ${BG_MASK} ${BG} -p ${HILO[1]})
else
  LO=$(fslstats ${BG} -p ${HILO[0]})
  HI=$(fslstats ${BG} -p ${HILO[1]})
fi

slice_fcn="slicer ${BG} -u -l ${DIR_SCRATCH}/CBAR_BG.lut -i ${LO} ${HI}"
for (( i=0; i<${NX}; i++ )); do
  slice_fcn="${slice_fcn} -x ${XPCT[${i}]} ${DIR_SCRATCH}/X${i}_BG.png"
done
for (( i=0; i<${NY}; i++ )); do
  slice_fcn="${slice_fcn} -y ${YPCT[${i}]} ${DIR_SCRATCH}/Y${i}_BG.png"
done
for (( i=0; i<${NZ}; i++ )); do
  slice_fcn="${slice_fcn} -z ${ZPCT[${i}]} ${DIR_SCRATCH}/Z${i}_BG.png"
done
eval ${slice_fcn}

# resize images
if [[ "${VERBOSE}" == "true" ]]; then echo ">>>resize background slices"; fi
TLS=($(ls ${DIR_SCRATCH}/*_BG.png))
for (( i=0; i<${#TLS[@]}; i++ )); do
  convert ${TLS[${i}]} -resize ${RESIZE_STR} ${TLS[${i}]}
done

if [[ -n ${BG_MASK} ]]; then
  if [[ "${VERBOSE}" == "true" ]]; then echo ">>>generate background mask slices"; fi
  slice_fcn="slicer ${BG_MASK} -u -l ${DIR_SCRATCH}/CBAR_MASK.lut -i 0 1"
  for (( i=0; i<${NX}; i++ )); do
    slice_fcn="${slice_fcn} -x ${XPCT[${i}]} ${DIR_SCRATCH}/X${i}_BGMASK.png"
  done
  for (( i=0; i<${NY}; i++ )); do
    slice_fcn="${slice_fcn} -y ${YPCT[${i}]} ${DIR_SCRATCH}/Y${i}_BGMASK.png"
  done
  for (( i=0; i<${NZ}; i++ )); do
    slice_fcn="${slice_fcn} -z ${ZPCT[${i}]} ${DIR_SCRATCH}/Z${i}_BGMASK.png"
  done
  eval ${slice_fcn}

  # resize
  if [[ "${VERBOSE}" == "true" ]]; then echo ">>>resize background mask slices"; fi
  TLS=($(ls ${DIR_SCRATCH}/*_BGMASK.png))
  for (( i=0; i<${#TLS[@]}; i++ )); do
    convert ${TLS[${i}]} -resize ${RESIZE_STR} ${TLS[${i}]}
  done
fi

# composite BG BG_MASK on background
if [[ "${VERBOSE}" == "true" ]]; then echo ">>>composite background slices on background panel"; fi
for (( i=0; i<${NX}; i++ )); do
  unset comp_fcn
  comp_fcn="composite ${DIR_SCRATCH}/X${i}_BG.png ${DIR_SCRATCH}/X${i}.png"
  if [[ -n ${BG_MASK} ]]; then
    comp_fcn="${comp_fcn} ${DIR_SCRATCH}/X${i}_BGMASK.png"
  fi
  comp_fcn="${comp_fcn} ${DIR_SCRATCH}/X${i}.png"
  eval ${comp_fcn}
done
for (( i=0; i<${NY}; i++ )); do
  unset comp_fcn
  comp_fcn="composite ${DIR_SCRATCH}/Y${i}_BG.png ${DIR_SCRATCH}/Y${i}.png"
  if [[ -n ${BG_MASK} ]]; then
    comp_fcn="${comp_fcn} ${DIR_SCRATCH}/Y${i}_BGMASK.png"
  fi
  comp_fcn="${comp_fcn} ${DIR_SCRATCH}/Y${i}.png"
  eval ${comp_fcn}
done
for (( i=0; i<${NZ}; i++ )); do
  unset comp_fcn
  comp_fcn="composite ${DIR_SCRATCH}/Z${i}_BG.png ${DIR_SCRATCH}/Z${i}.png"
  if [[ -n ${BG_MASK} ]]; then
    comp_fcn="${comp_fcn} ${DIR_SCRATCH}/Z${i}_BGMASK.png"
  fi
  comp_fcn="${comp_fcn} ${DIR_SCRATCH}/Z${i}.png"
  eval ${comp_fcn}
done
if [[ "${VERBOSE}" == "true" ]]; then echo ">>>BG slice PNGS generated"; fi

# Add Foreground Overlays ======================================================
if [[ -n ${FG} ]]; then
  if [[ "${VERBOSE}" == "true" ]]; then echo ">>>add foreground overlay(s)"; fi
  for (( i=0; i<${#FG[@]}; i++ )); do
    unset HILO LO HI
    HILO=(${FG_THRESH[${i}]//,/ })
    if [[ -z ${FG_MASK} ]] || [[ "${FG_MASK[${i}]}" != "null" ]]; then
      LO=$(fslstats ${FG[${i}]} -p ${HILO[0]})
      HI=$(fslstats ${FG[${i}]} -p ${HILO[1]})
    else
      LO=$(fslstats -K ${FG_MASK[${i}]} ${FG[${i}]} -p ${HILO[0]})
      HI=$(fslstats -K ${FG_MASK[${i}]} ${FG[${i}]} -p ${HILO[1]})
    fi

    ## generate color bar
    if [[ "${VERBOSE}" == "true" ]]; then echo ">>>>>>make FG colorbar"; fi
    Rscript ${INC_R}/makeColors.R \
      "palette" ${FG_COLOR[${i}]} "n" 200 \
      "order" ${FG_ORDER[${i}]} "bg" ${COLOR_PANEL} \
      "dir.save" ${DIR_SCRATCH} "prefix" "CBAR_FG_${i}"
  
    ### add labels to color bar
    if [[ "${FG_CBAR[${i}]}" == "true" ]]; then
      if [[ "${VERBOSE}" == "true" ]]; then echo ">>>>>>add colorbar labels"; fi
      text_fcn='TTXT=$(printf "%0.'${COLOR_DECIMAL}'f\n" ${LO})'
      eval ${text_fcn}
      convert -background "transparent" -fill ${COLOR_TEXT} \
        -font ${FONT} -pointsize ${FONT_SIZE} \
        caption:"${TTXT}" -rotate 90 ${DIR_SCRATCH}/LABEL_LO.png
      text_fcn='TTXT=$(printf "%0.'${COLOR_DECIMAL}'f\n" ${HI})'
      eval ${text_fcn}
      convert -background "transparent" -fill ${COLOR_TEXT} \
        -font ${FONT} -pointsize ${FONT_SIZE} \
        caption:"${TTXT}" -rotate 90 ${DIR_SCRATCH}/LABEL_HI.png
      composite -gravity SouthEast \
        ${DIR_SCRATCH}/LABEL_LO.png \
        ${DIR_SCRATCH}/CBAR_FG_${i}.png \
        ${DIR_SCRATCH}/CBAR_FG_${i}.png
      composite -gravity NorthEast \
        ${DIR_SCRATCH}/LABEL_HI.png \
        ${DIR_SCRATCH}/CBAR_FG_${i}.png \
        ${DIR_SCRATCH}/CBAR_FG_${i}.png
    fi

    ## generate slice PNGs - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if [[ "${VERBOSE}" == "true" ]]; then echo ">>>>>>generate foreground slices"; fi
    slice_fcn="slicer ${FG[${i}]}"
    slice_fcn="${slice_fcn} -u "
    slice_fcn="${slice_fcn} -l ${DIR_SCRATCH}/CBAR_FG_${i}.lut"
    slice_fcn="${slice_fcn} -i ${LO} ${HI}"
    for (( j=0; j<${NX}; j++ )); do
      slice_fcn="${slice_fcn} -x ${XPCT[${j}]} ${DIR_SCRATCH}/X${j}_FG_${i}.png"
    done
    for (( j=0; j<${NY}; j++ )); do
      slice_fcn="${slice_fcn} -y ${YPCT[${j}]} ${DIR_SCRATCH}/Y${j}_FG_${i}.png"
    done
    for (( j=0; j<${NZ}; j++ )); do
      slice_fcn="${slice_fcn} -z ${ZPCT[${j}]} ${DIR_SCRATCH}/Z${j}_FG_${i}.png"
    done
    eval ${slice_fcn}
    # resize images
    if [[ "${VERBOSE}" == "true" ]]; then echo ">>>>>>resize foreground slices"; fi
    TLS=($(ls ${DIR_SCRATCH}/*_FG_${i}.png))
    for (( j=0; j<${#TLS[@]}; j++ )); do
      convert ${TLS[${j}]} -resize ${RESIZE_STR} ${TLS[${j}]}
    done

    # set foreground mask
    if [[ -z ${FG_MASK} ]] || [[ "${FG_MASK[${i}]}" == "null" ]]; then
      if [[ "${VERBOSE}" == "true" ]]; then echo ">>>>>>set foreground mask"; fi
      fslmaths ${FG[${i}]} -thr ${LO} -bin ${DIR_SCRATCH}/FGMASK_${i}.nii.gz
      FG_MASK[${i}]=${DIR_SCRATCH}/FGMASK_${i}.nii.gz
    fi
    
    if [[ -n ${FG_MASK} ]] || [[ "${FG_MASK[${i}]}" != "null" ]]; then
      if [[ "${VERBOSE}" == "true" ]]; then echo ">>>>>>get foreground mask slices"; fi
      slice_fcn="slicer ${FG_MASK[${i}]} -u -l ${DIR_SCRATCH}/CBAR_MASK.lut -i 0 1"
      for (( j=0; j<${NX}; j++ )); do
        FTEMP="${DIR_SCRATCH}/X${j}_FGMASK_${i}.png"
        slice_fcn="${slice_fcn} -x ${XPCT[${j}]} ${FTEMP}"
      done
      for (( j=0; j<${NY}; j++ )); do
        FTEMP="${DIR_SCRATCH}/Y${j}_FGMASK_${i}.png"
        slice_fcn="${slice_fcn} -y ${YPCT[${j}]} ${FTEMP}"
      done
      for (( j=0; j<${NZ}; j++ )); do
        FTEMP="${DIR_SCRATCH}/Z${j}_FGMASK_${i}.png"
        slice_fcn="${slice_fcn} -z ${ZPCT[${j}]} ${FTEMP}"
      done
      eval ${slice_fcn}
      # resize
      if [[ "${VERBOSE}" == "true" ]]; then echo ">>>>>>resize foreground mask"; fi
      TLS=($(ls ${DIR_SCRATCH}/*_FGMASK_${i}.png))
      for (( j=0; j<${#TLS[@]}; j++ )); do
        convert ${TLS[${j}]} -resize ${RESIZE_STR} ${TLS[${j}]}
      done
    fi

    ## set background transparency and overlay on background - - - - - - - - - -
    if [[ "${VERBOSE}" == "true" ]]; then echo ">>>set foreground transparency for each slice and composite on background"; fi
    for (( j=0; j<${NX}; j++ )); do
      unset comp_fcn
      comp_fcn="composite"
      comp_fcn="${comp_fcn} -dissolve ${FG_ALPHA}%"
      comp_fcn="${comp_fcn} ${DIR_SCRATCH}/X${j}_FG_${i}.png"
      comp_fcn="${comp_fcn} ${DIR_SCRATCH}/X${j}.png"
      if [[ -n ${FG_MASK} ]] || [[ "${FG_MASK[${i}]}" != "null" ]]; then
        comp_fcn="${comp_fcn} ${DIR_SCRATCH}/X${j}_FGMASK_${i}.png"
      fi
      comp_fcn="${comp_fcn} ${DIR_SCRATCH}/X${j}.png"
      eval ${comp_fcn}
    done
    for (( j=0; j<${NY}; j++ )); do
      unset comp_fcn
      comp_fcn="composite"
      comp_fcn="${comp_fcn} -dissolve ${FG_ALPHA}%"
      comp_fcn="${comp_fcn} ${DIR_SCRATCH}/Y${j}_FG_${i}.png"
      comp_fcn="${comp_fcn} ${DIR_SCRATCH}/Y${j}.png"
      if [[ -n ${FG_MASK} ]] || [[ "${FG_MASK[${i}]}" != "null" ]]; then
        comp_fcn="${comp_fcn} ${DIR_SCRATCH}/Y${j}_FGMASK_${i}.png"
      fi
      comp_fcn="${comp_fcn} ${DIR_SCRATCH}/Y${j}.png"
      eval ${comp_fcn}
    done
    for (( j=0; j<${NZ}; j++ )); do
      unset comp_fcn
      comp_fcn="composite"
      comp_fcn="${comp_fcn} -dissolve ${FG_ALPHA}%"
      comp_fcn="${comp_fcn} ${DIR_SCRATCH}/Z${j}_FG_${i}.png"
      comp_fcn="${comp_fcn} ${DIR_SCRATCH}/Z${j}.png"
      if [[ -n ${FG_MASK} ]] || [[ "${FG_MASK[${i}]}" != "null" ]]; then
        comp_fcn="${comp_fcn} ${DIR_SCRATCH}/Z${j}_FGMASK_${i}.png"
      fi
      comp_fcn="${comp_fcn} ${DIR_SCRATCH}/Z${j}.png"
      eval ${comp_fcn}
    done
  done
if [[ "${VERBOSE}" == "true" ]]; then echo ">>>FG slice PNGS generated"; fi
fi

# Add ROI ======================================================================
if [[ -n ${ROI} ]]; then
  if [[ "${VERBOSE}" == "true" ]]; then echo ">>>generate ROI"; fi
  ## total number of ROIs
  ROI_N=$(fslstats ${ROI} -p 100)
  ## convert ROIs to outlines
  if [[ "${VERBOSE}" == "true" ]]; then echo ">>>convert ROI to outlines"; fi
  labelOutline --label ${ROI} --prefix ROI_OUTLINE --dir-save ${DIR_SCRATCH}
  # make ROI mask
  if [[ "${VERBOSE}" == "true" ]]; then echo ">>>make ROI mask"; fi
  fslmaths ${DIR_SCRATCH}/ROI_OUTLINE.nii.gz -bin ${DIR_SCRATCH}/ROI_MASK.nii.gz
  ## generate color bar
  if [[ "${VERBOSE}" == "true" ]]; then echo ">>>make ROI color bar"; fi
  Rscript ${INC_R}/makeColors.R \
    "palette" ${ROI_COLOR} "n" ${ROI_N} \
    "order" ${ROI_ORDER} "bg" ${COLOR_PANEL} \
    "dir.save" ${DIR_SCRATCH} "prefix" "CBAR_ROI"

  ## get slices
  if [[ "${VERBOSE}" == "true" ]]; then echo ">>>get ROI slices"; fi
  slice_fcn="slicer ${DIR_SCRATCH}/ROI_OUTLINE.nii.gz"
  slice_fcn="${slice_fcn} -u -l ${DIR_SCRATCH}/CBAR_ROI.lut -i 0 ${ROI_N}"
  for (( i=0; i<${NX}; i++ )); do
    slice_fcn="${slice_fcn} -x ${XPCT[${i}]} ${DIR_SCRATCH}/X${i}_ROI.png"
  done
  for (( i=0; i<${NY}; i++ )); do
    slice_fcn="${slice_fcn} -y ${YPCT[${i}]} ${DIR_SCRATCH}/Y${i}_ROI.png"
  done
  for (( i=0; i<${NZ}; i++ )); do
    slice_fcn="${slice_fcn} -z ${ZPCT[${i}]} ${DIR_SCRATCH}/Z${i}_ROI.png"
  done
  eval ${slice_fcn}

  ## resize images
  if [[ "${VERBOSE}" == "true" ]]; then echo ">>>resize ROI slices"; fi
  TLS=($(ls ${DIR_SCRATCH}/*_ROI.png))
  for (( i=0; i<${#TLS[@]}; i++ )); do
    convert ${TLS[${i}]} -resize ${RESIZE_STR} ${TLS[${i}]}
  done

  ## get slices for overlay mask
  if [[ "${VERBOSE}" == "true" ]]; then echo ">>>slice ROI mask"; fi
  slice_fcn="slicer ${DIR_SCRATCH}/ROI_MASK.nii.gz"
  slice_fcn="${slice_fcn} -u -l ${DIR_SCRATCH}/CBAR_MASK.lut -i 0 1"
  for (( i=0; i<${NX}; i++ )); do
    slice_fcn="${slice_fcn} -x ${XPCT[${i}]} ${DIR_SCRATCH}/X${i}_ROIMASK.png"
  done
  for (( i=0; i<${NY}; i++ )); do
    slice_fcn="${slice_fcn} -y ${YPCT[${i}]} ${DIR_SCRATCH}/Y${i}_ROIMASK.png"
  done
  for (( i=0; i<${NZ}; i++ )); do
    slice_fcn="${slice_fcn} -z ${ZPCT[${i}]} ${DIR_SCRATCH}/Z${i}_ROIMASK.png"
  done
  eval ${slice_fcn}

  ## resize overlay mask
  if [[ "${VERBOSE}" == "true" ]]; then echo ">>>resize ROI mask"; fi
  TLS=($(ls ${DIR_SCRATCH}/*_ROIMASK.png))
  for (( i=0; i<${#TLS[@]}; i++ )); do
    convert ${TLS[${i}]} -resize ${RESIZE_STR} ${TLS[${i}]}
  done

  ## composite ROIs on background
  if [[ "${VERBOSE}" == "true" ]]; then echo ">>>composite ROIs on background"; fi
  for (( i=0; i<${NX}; i++ )); do
    composite ${DIR_SCRATCH}/X${i}_ROI.png \
      ${DIR_SCRATCH}/X${i}.png \
      ${DIR_SCRATCH}/X${i}_ROIMASK.png \
      ${DIR_SCRATCH}/X${i}.png
  done
  for (( i=0; i<${NY}; i++ )); do
    composite ${DIR_SCRATCH}/Y${i}_ROI.png \
      ${DIR_SCRATCH}/Y${i}.png \
      ${DIR_SCRATCH}/Y${i}_ROIMASK.png \
      ${DIR_SCRATCH}/Y${i}.png
  done
  for (( i=0; i<${NZ}; i++ )); do
    composite ${DIR_SCRATCH}/Z${i}_ROI.png \
      ${DIR_SCRATCH}/Z${i}.png \
      ${DIR_SCRATCH}/Z${i}_ROIMASK.png \
      ${DIR_SCRATCH}/Z${i}.png
  done
  if [[ "${VERBOSE}" == "true" ]]; then echo ">>>ROI slice PNGS generated"; fi
fi

# Add labels after FG and ROIs are composited ----------------------------------
for (( i=0; i<${NX}; i++ )); do
  if [[ "${LABEL_NO_SLICE}" == "false" ]]; then
    if [[ "${VERBOSE}" == "true" ]]; then echo ">>>add slice labels X"; fi
    if [[ "${LABEL_USE_VOX}" == "false" ]]; then
      LABEL_X=$(ezMath -x "((${ORIGIN[0]}/${PIXDIM[0]})-${XVOX[${i}]})*${PIXDIM[0]}" -d ${LABEL_DECIMAL})
      #LABEL_X=$(echo "scale=${LABEL_DECIMAL}; ${ORIGIN[0]}/${PIXDIM[0]}" | bc -l)
      #LABEL_X=$(echo "scale=${LABEL_DECIMAL}; ${LABEL_X}-${XVOX[${i}]}" | bc -l)
      #LABEL_X=$(echo "scale=${LABEL_DECIMAL}; ${LABEL_X}*${PIXDIM[0]}" | bc -l)
      LABEL_X="${LABEL_X}mm"
    else
      LABEL_X=${XVOX[${i}]}
    fi
    LABEL_X="x=${LABEL_X}"
    mogrify -font ${FONT} -pointsize ${FONT_SIZE} \
      -fill "${COLOR_TEXT}" -undercolor "transparent" \
      -gravity NorthWest -annotate +10+10 "${LABEL_X}" \
      ${DIR_SCRATCH}/X${i}.png
  fi
done
for (( i=0; i<${NY}; i++ )); do
  if [[ "${LABEL_NO_SLICE}" == "false" ]]; then
    if [[ "${VERBOSE}" == "true" ]]; then echo ">>>add slice labels Y"; fi
    if [[ "${LABEL_USE_VOX}" == "false" ]]; then
      LABEL_Y=$(ezMath -x "((${ORIGIN[1]}/${PIXDIM[1]})-${YVOX[${i}]})*${PIXDIM[1]}" -d ${LABEL_DECIMAL})
      #LABEL_Y=$(echo "scale=${LABEL_DECIMAL}; ${ORIGIN[1]}/${PIXDIM[1]}" | bc -l)
      #LABEL_Y=$(echo "scale=${LABEL_DECIMAL}; ${LABEL_Y}-${YVOX[${i}]}" | bc -l)
      #LABEL_Y=$(echo "scale=${LABEL_DECIMAL}; ${LABEL_Y}*${PIXDIM[1]}" | bc -l)
      LABEL_Y="${LABEL_Y}mm"
    else
      LABEL_Y=${YVOX[${i}]}
    fi
    LABEL_Y="y=${LABEL_Y}"
    mogrify -font ${FONT} -pointsize ${FONT_SIZE} \
      -fill "${COLOR_TEXT}" -undercolor "transparent" \
      -gravity NorthWest -annotate +10+10 "${LABEL_Y}" \
      ${DIR_SCRATCH}/Y${i}.png
  fi
done
for (( i=0; i<${NZ}; i++ )); do
  if [[ "${LABEL_NO_SLICE}" == "false" ]]; then
    if [[ "${VERBOSE}" == "true" ]]; then echo ">>>add slice labels Z"; fi
    if [[ "${LABEL_USE_VOX}" == "false" ]]; then
      LABEL_Z=$(ezMath -x "((${ORIGIN[2]}/${PIXDIM[2]})-${ZVOX[${i}]})*${PIXDIM[2]}" -d ${LABEL_DECIMAL})
      #LABEL_Z=$(echo "scale=${LABEL_DECIMAL}; ${ORIGIN[2]}/${PIXDIM[2]}" | bc -l)
      #LABEL_Z=$(echo "scale=${LABEL_DECIMAL}; ${LABEL_Z}-${ZVOX[${i}]}" | bc -l)
      #LABEL_Z=$(echo "scale=${LABEL_DECIMAL}; ${LABEL_Z}*${PIXDIM[2]}" | bc -l)
      LABEL_Z="${LABEL_Z}mm"
    else
      LABEL_Z=${ZVOX[${i}]}
    fi
    LABEL_Z="z=${LABEL_Z}"
    mogrify -font ${FONT} -pointsize ${FONT_SIZE} \
      -fill "${COLOR_TEXT}" -undercolor "transparent" \
      -gravity NorthWest -annotate +10+10 "${LABEL_Z}" \
      ${DIR_SCRATCH}/Z${i}.png
  fi
done

# merge PNGs according to prescribed layout ====================================
# montage rows - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
if [[ "${VERBOSE}" == "true" ]]; then echo ">>>montage slices by rows"; fi
XCOUNT=0
YCOUNT=0
ZCOUNT=0
ROW_LAYOUT=(${LAYOUT//\;/ })
for (( i=0; i<${#ROW_LAYOUT[@]}; i++ )); do
  COL_LAYOUT=(${ROW_LAYOUT[${i}]//\,/ })
  montage_fcn="montage"    
  for (( j=0; j<${#COL_LAYOUT[@]}; j++ )); do
     TEMP=(${COL_LAYOUT[${j}]//\:/ })
     if [[ "${TEMP[1]}" =~ "x" ]]; then
       for (( k=0; k<${TEMP[0]}; k++ )); do
         montage_fcn="${montage_fcn} ${DIR_SCRATCH}/X${XCOUNT}.png"
         XCOUNT=$((${XCOUNT}+1))
       done
     fi
     if [[ "${TEMP[1]}" =~ "y" ]]; then
       for (( k=0; k<${TEMP[0]}; k++ )); do
         montage_fcn="${montage_fcn} ${DIR_SCRATCH}/Y${YCOUNT}.png"
         YCOUNT=$((${YCOUNT}+1))
       done
     fi
     if [[ "${TEMP[1]}" =~ "z" ]]; then
       for (( k=0; k<${TEMP[0]}; k++ )); do
         montage_fcn="${montage_fcn} ${DIR_SCRATCH}/Z${ZCOUNT}.png"
         ZCOUNT=$((${ZCOUNT}+1))
       done
     fi
  done
  montage_fcn="${montage_fcn} -tile x1"
  montage_fcn="${montage_fcn} -geometry +0+0"
  montage_fcn="${montage_fcn} -gravity center"
  montage_fcn=${montage_fcn}' -background "'${COLOR_PANEL}'"'
  montage_fcn="${montage_fcn} ${DIR_SCRATCH}/image_row${i}.png"
  eval ${montage_fcn}
done

# montage rows into columns - - - - - - - - - - - - - - - - - - - - - - - - - -
if [[ "${VERBOSE}" == "true" ]]; then echo ">>>montage rows of slices into columns"; fi
FLS=($(ls ${DIR_SCRATCH}/image_row*.png))
if [[ ${#FLS[@]} -gt 1 ]]; then
  montage_fcn="montage"
  for (( i=0; i<${#FLS[@]}; i++ )); do
    montage_fcn="${montage_fcn} ${DIR_SCRATCH}/image_row${i}.png"
  done
  montage_fcn="${montage_fcn} -tile 1x"
  montage_fcn="${montage_fcn} -geometry +0+0"
  montage_fcn="${montage_fcn} -gravity center"
  montage_fcn=${montage_fcn}' -background "'${COLOR_PANEL}'"'
  montage_fcn="${montage_fcn} ${DIR_SCRATCH}/image_col.png"
  eval ${montage_fcn}
else
  mv ${DIR_SCRATCH}/image_row0.png ${DIR_SCRATCH}/image_col.png
fi

# add color bars - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
if [[ "${VERBOSE}" == "true" ]]; then echo ">>> add color bar onto rightward edge"; fi
unset CBAR_LS
if [[ "${BG_CBAR}" == "true" ]]; then
  CBAR_LS+=("${DIR_SCRATCH}/CBAR_BG.png")
fi
if [[ -n ${FG} ]]; then
  TLS=($(ls ${DIR_SCRATCH}/CBAR_FG*.png))
  TBOOL=(${FG_CBAR//,/ })
  for (( i=0; i<${#TLS[@]}; i++ )); do
    if [[ "${TBOOL[${i}]}" == "true" ]]; then
      CBAR_LS+=("${TLS[${i}]}")
    fi
  done
fi
if [[ -n ${ROI} ]]; then
  TLS=($(ls ${DIR_SCRATCH}/CBAR_ROI*.png))
  TBOOL=(${ROI_CBAR//,/ })
  for (( i=0; i<${#TLS[@]}; i++ )); do
    if [[ "${TBOOL[${i}]}" == "true" ]]; then
      CBAR_LS+=("${TLS[${i}]}")
    fi
  done
fi

if [[ ${#CBAR_LS[@]} -gt 0 ]]; then  
  montage_fcn="montage ${DIR_SCRATCH}/image_col.png"
  for (( i=0; i<${#CBAR_LS[@]}; i++ )); do
    montage_fcn="${montage_fcn} ${CBAR_LS[${i}]}"
  done
  montage_fcn="${montage_fcn} -tile x1"
  montage_fcn="${montage_fcn} -geometry +0+0"
  montage_fcn="${montage_fcn} -gravity center"
  montage_fcn=${montage_fcn}' -background "transparent"'
  montage_fcn="${montage_fcn} ${DIR_SCRATCH}/${FILENAME}.png"
  eval ${montage_fcn}
else
  mv ${DIR_SCRATCH}/image_col.png ${DIR_SCRATCH}/${FILENAME}.png
fi

# add laterality label if desired ----------------------------------------------
if [[ "${LABEL_NO_LR}" == "false" ]]; then
  if [[ "${VERBOSE}" == "true" ]]; then echo ">>>add laterality label"; fi
  if [[ "${ORIENT,,}" == *"r"* ]]; then
    TTXT="R"
  else
    TTXT="L"
  fi
  mogrify -font ${FONT} -pointsize ${FONT_SIZE} \
    -fill "${COLOR_TEXT}" -undercolor "transparent" \
    -gravity SouthWest -annotate +10+10 "${TTXT}" \
    ${DIR_SCRATCH}/${FILENAME}.png
fi

# move final png file===========================================================
if [[ "${VERBOSE}" == "true" ]]; then echo ">>>save PNG output"; fi
mv ${DIR_SCRATCH}/${FILENAME}.png ${DIR_SAVE}/

# move optional outputs, slices and color bars----------------------------------
if [[ "${KEEP_SLICE}" == "true" ]]; then
  if [[ "${VERBOSE}" == "true" ]]; then echo ">>>keep optional outputs (slices, layers and color bars)"; fi
  for (( i=0; i<${NX}; i++ )); do
    mv ${DIR_SCRATCH}/X${i}.png ${DIR_SAVE}/${FILENAME}_X${i}.png
  done
  for (( i=0; i<${NY}; i++ )); do
    mv ${DIR_SCRATCH}/Y${i}.png ${DIR_SAVE}/${FILENAME}_Y${i}.png
  done
  for (( i=0; i<${NZ}; i++ )); do
    mv ${DIR_SCRATCH}/Z${i}.png ${DIR_SAVE}/${FILENAME}_Z${i}.png
  done
fi
if [[ "${KEEP_CBAR}" == "true" ]]; then
  rename CBAR ${FILENAME}_CBAR ${DIR_SCRATCH}/*.png
  mv {DIR_SCRATCH}/${FILENAME}_CBAR*.png ${DIR_SAVE}/
fi

#-------------------------------------------------------------------------------
# End of Function
#-------------------------------------------------------------------------------
if [[ "${VERBOSE}" == "true" ]]; then echo ">>>DONE"; fi
exit 0


